<!DOCTYPE html>
<!-- saved from url=(0036)http://localhost:8081/iframe/v5.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!--<base target="_parent">--><base href="." target="_parent">
    <title>Output</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        overflow-y: hidden;
      }
    </style>
  <!--<base href="http://localhost:8080/public/sessions/pgoatz5d3xvarugpuo4cromdilywdyymu55kuajh4xpmf3p3/assets/kcvt2u3enog2ii5ygwk6q4jrte/">--><base href="." target="_parent"><script src="./react.development.js"></script><script src="./react-dom.development.js"></script><link rel="stylesheet" href="./main(2).css"><link rel="stylesheet" href="./css2"></head>
  <body>
    <div id="root"><div class="rounded-md border-t border-solid border-gray-300 font-inter font-medium text-gray-600"><div class="border-b-solid flex gap-x-5 gap-y-3 border-b border-b-gray-300 bg-blue-100 p-3"><div class="flex flex-row items-baseline"><label for="connection" class="pr-1 uppercase mb-1 text-sm font-medium">Connection</label><select id="connection" class=" appearance-none rounded-lg border border-gray-300 bg-gray-50 bg-caret-down bg-[length:10px] bg-[center_right_10px] bg-no-repeat p-2 pr-5 text-sm focus:border-blue-500 focus:ring-blue-500"><option value="conn">conn</option></select></div><div class="flex flex-row items-baseline"><label for="assign_to" class="pr-1 uppercase mb-1 text-sm font-medium">Assign To</label><input type="text" name="assign_to" class="rounded-lg border border-gray-300 bg-gray-50 p-1.5 text-sm focus:border-blue-500 focus:ring-blue-500" value="applied_resource"></div></div></div></div>
    <script>
      "use strict";

      // Invoke the init function in a separate context for better isolation
      function applyInit(init, ctx, data) {
        init(ctx, data);
      }

      (() => {
        const state = {
          token: null,
          importPromise: null,
          eventHandlers: {},
          eventQueue: [],
          syncHandler: null,
          secretHandler: null,
        };

        function postMessage(message) {
          window.parent.postMessage({ token: state.token, ...message }, "*");
        }

        const ctx = {
          root: document.getElementById("root"),

          handleEvent(event, callback) {
            if (state.eventHandlers[event]) {
              throw new Error(
                `Handler has already been defined for event "${event}"`
              );
            }

            state.eventHandlers[event] = callback;

            while (
              state.eventQueue.length > 0 &&
              state.eventHandlers[state.eventQueue[0].event]
            ) {
              const { event, payload } = state.eventQueue.shift();
              const handler = state.eventHandlers[event];
              handler(payload);
            }
          },

          pushEvent(event, payload = null) {
            postMessage({ type: "event", event, payload });
          },

          importCSS(url) {
            return new Promise((resolve, reject) => {
              const linkEl = document.createElement("link");
              linkEl.addEventListener(
                "load",
                (event) => {
                  resolve();
                },
                { once: true }
              );
              linkEl.rel = "stylesheet";
              linkEl.href = url;
              document.head.appendChild(linkEl);
            });
          },

          importJS(url) {
            return new Promise((resolve, reject) => {
              const scriptEl = document.createElement("script");
              scriptEl.addEventListener(
                "load",
                (event) => {
                  resolve();
                },
                { once: true }
              );
              scriptEl.src = url;
              document.head.appendChild(scriptEl);
            });
          },

          handleSync(callback) {
            state.syncHandler = callback;
          },

          selectSecret(callback, preselectName, options = {}) {
            state.secretHandler = callback;
            postMessage({ type: "selectSecret", preselectName, options });
          },

          setSmartCellEditorIntellisenseNode(node, cookie) {
            postMessage({
              type: "setSmartCellEditorIntellisenseNode",
              node,
              cookie,
            });
          },
        };

        window.addEventListener("message", (event) => {
          if (event.source === window.parent) {
            handleParentMessage(event.data);
          }
        });

        function handleParentMessage(message) {
          if (message.type === "readyReply") {
            state.token = message.token;
            onReady();

            // Set the base URL for relative URLs
            const baseUrlEl = document.createElement("base");
            baseUrlEl.href = message.baseUrl;
            document.head.appendChild(baseUrlEl);
            // We already entered the script and the base URL change
            // doesn't impact this import call, so we use the absolute
            // URL instead
            state.importPromise = import(`${message.baseUrl}${message.jsPath}`);
          } else if (message.type === "init") {
            state.importPromise
              .then((module) => {
                const init = module.init;

                if (!init) {
                  const fns = Object.keys(module);
                  throw new Error(
                    `Expected the module to export an init function, but found: ${fns.join(
                      ", "
                    )}`
                  );
                }

                applyInit(init, ctx, message.data);
              })
              .catch((error) => {
                renderErrorMessage(
                  `Failed to load the widget JS module, got the following error:\n\n    ${error.message}\n\nSee the browser console for more details. If running behind an authentication proxy, make sure the /public/* routes are publicly accessible.`
                );

                throw error;
              });
          } else if (message.type === "event") {
            const { event, payload } = message;
            const handler = state.eventHandlers[event];

            if (state.eventQueue.length === 0 && handler) {
              handler(payload);
            } else {
              state.eventQueue.push({ event, payload });
            }
          } else if (message.type === "sync") {
            Promise.resolve(state.syncHandler && state.syncHandler()).then(
              () => {
                postMessage({ type: "syncReply" });
              }
            );
          } else if (message.type === "secretSelected") {
            state.secretHandler && state.secretHandler(message.secretName);
          }
        }

        postMessage({ type: "ready" });

        function onReady() {
          // Report height changes

          const resizeObserver = new ResizeObserver((entries) => {
            postMessage({ type: "resize", height: document.body.scrollHeight });
          });

          resizeObserver.observe(document.body);

          // Forward relevant DOM events

          window.addEventListener("mousedown", (event) => {
            postMessage({ type: "domEvent", event: { type: "mousedown" } });
          });

          window.addEventListener("focus", (event) => {
            postMessage({ type: "domEvent", event: { type: "focus" } });
          });

          window.addEventListener("keydown", (event) => {
            postMessage({
              type: "domEvent",
              event: keyboardEventToPayload(event),
              isTargetEditable: isEditableElement(event.target),
            });
          });
        }

        function isEditableElement(element) {
          return element.matches("input, textarea, [contenteditable]");
        }

        function keyboardEventToPayload(event) {
          const {
            altKey,
            code,
            ctrlKey,
            isComposing,
            key,
            location,
            metaKey,
            repeat,
            shiftKey,
          } = event;

          return {
            type: event.type,
            props: {
              altKey,
              code,
              ctrlKey,
              isComposing,
              key,
              location,
              metaKey,
              repeat,
              shiftKey,
            },
          };
        }

        function renderErrorMessage(message) {
          ctx.root.innerHTML = `
            <div style="color: #FF3E38; white-space: pre-wrap; word-break: break-word;">${message}</div>
          `;
        }
      })();
    </script>
  

</body></html>